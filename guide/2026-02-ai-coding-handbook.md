# AI Coding 指导手册（2026 年 2 月版）

> 更新日期：2026-02-13  
> 适用对象：把 AI 当“结对工程师 / 工程代理（Agent）”使用的个人与团队  
> 目标：更快交付、更少返工、更稳定质量（可复现、可审查、可回滚）  
> 本版重点：覆盖 2025-02 到 2026-02 的关键变化，聚焦 MCP、Skills、蜂群模式

## 目录

1. [原则](#原则)
2. [近一年关键变化（2025-02 -> 2026-02）](#近一年关键变化2025-02---2026-02)
3. [30 分钟快速开始（含 MCP/Skills/蜂群）](#30-分钟快速开始含-mcpskills蜂群)
4. [标准工作流（从需求到合并，面向 Agent）](#标准工作流从需求到合并面向-agent)
5. [MCP：把“上下文”变成“可调用工具”](#mcp把上下文变成可调用工具)
6. [Skills：把“好习惯”固化成“可复用指令包”](#skills把好习惯固化成可复用指令包)
7. [蜂群模式：并行化的多 Agent 协作](#蜂群模式并行化的多-agent-协作)
8. [提示词模板（MCP/Skills/蜂群专项）](#提示词模板mcpskills蜂群专项)
9. [质量门禁与自检清单（更适配 Agent）](#质量门禁与自检清单更适配-agent)
10. [代码评审要点（人审 AI 产出，含工具风险）](#代码评审要点人审-ai-产出含工具风险)
11. [安全与合规（含 MCP/权限/数据）](#安全与合规含-mcp权限数据)
12. [协作约定（团队落地）](#协作约定团队落地)
13. [常见失败模式与修复手段（新增：MCP/蜂群）](#常见失败模式与修复手段新增mcp蜂群)
14. [本仓库相关参考](#本仓库相关参考)

---

## 原则

1. **AI 不替你负责，只替你加速**：任何可上线的变更，都必须满足可读、可测、可回滚。
2. **先写完成标准，再让 AI 动手**：验收标准写不清，AI 只能猜，返工必然更高。
3. **把 AI 限制在“局部正确”的约束里**：给范围、给文件、给接口、给边界条件，避免“大而全”的想象。
4. **输出必须可复现**：关键命令、关键日志、关键配置要能在本机/CI 重跑。
5. **高风险改动先做最小实验**：先验证假设（小 patch、小实验、小开关），再扩大改动面。

---

## 近一年关键变化（2025-02 -> 2026-02）

这一年的变化可以概括为：AI 从“聊天式建议”进化为“能动手的工程代理（Agent）”，围绕它的工程方法也随之变化。

### 1) 从“生成代码”到“执行工作流”

- AI 不只输出代码片段，还会读项目结构、跑命令、改文件、写测试、做 review、产出变更说明。
- 工程要求随之升级：权限边界清晰、输出可审查、操作可追溯、失败可回滚。

### 2) MCP：从“贴上下文”到“连接工具与数据源”

- 过去：你把 issue、日志、设计稿复制粘贴进对话，AI 在文本里推断。
- 现在：通过 MCP（Model Context Protocol）把外部系统（issue tracker、代码仓库、监控、数据库、文档）变成可引用、可调用、可约束的“工具/资源”。
- 结果：事实更准确，但风险也上升：外部调用的权限、数据泄露、误写入、不可追溯。

### 3) Skills：从“个人提示词”到“组织级可复用能力”

- 过去：每个人有自己的 prompt；风格不一致、质量波动大、复用成本高。
- 现在：把成功的流程与约束写成 `SKILL.md`（指令包），做成团队可共享的能力单元。
- 结果：一致性提升，但也引入“技能债”：需要版本化、评审、维护、范围控制。

### 4) 蜂群模式：从“单 Agent”到“多 Agent 并行协作”

- 过去：一个对话窗口串行推进，容易卡在某个细节或被单一视角误导。
- 现在：把任务拆成多个 work package，同时让多个 Agent 分工（实现/测试/审计/文档/回归/性能/迁移）。
- 结果：吞吐提升，但必须建立协调协议、冲突控制、集成策略与统一验收口径。

---

## 30 分钟快速开始（含 MCP/Skills/蜂群）

目标是“跑通一次闭环”，而不是一次性写成完美方案。

1. **写 5 行需求**（必须包含）
   - 目标用户与场景
   - 期望行为（输入 -> 输出）
   - 不做什么（非目标）
   - 验收标准（可测量、可执行）
   - 风险点（性能/安全/兼容/数据）
2. **选一个 Skill 当作工作模式**（没有也没关系，先用模板）
   - 例：`$bugfix`、`$refactor-safe`、`$api-design`、`$security-review`
3. **连接 1-2 个 MCP 数据源**（能只读就先只读）
   - 例：issue tracker（需求来源）+ 代码仓库（文件/PR），或监控（错误证据）
4. **给 AI 5 个事实（避免猜测）**
   - 语言/框架/运行方式（build/test/dev 命令）
   - 关键入口文件/模块
   - 约束（不能改公共 API、不能引入新依赖、必须兼容旧数据等）
   - 现有测试/CI 情况
   - 预期交付物（patch/PR/迁移脚本/文档）
5. **让 AI 先产出“计划 + 切分 + 验证点”**（不要一上来写代码）
   - 先要改哪些文件
   - 每步怎么验证（命令/测试/观测）
   - 失败如何回滚
6. **先做最小闭环**：让功能跑起来或让 bug 可复现，再扩大范围。
7. **需要并行时开蜂群**：至少分出“实现 Agent”和“审计 Agent（review/安全/回归）”。

---

## 标准工作流（从需求到合并，面向 Agent）

### 0) 选择模式：单 Agent or 蜂群

- **单 Agent**：改动面小、上下文简单、验证路径明确。
- **蜂群**：改动面大、需要多类专长或希望并行推进。

### 1) 需求与验收（Definition of Done）

建议在任务开始前写清：

- 行为：给定输入 A/B/C，输出/副作用是什么
- 边界：空值、超长、异常、超时、重试、幂等
- 兼容：旧版本客户端/旧数据/旧配置是否受影响
- 指标：延迟、QPS、内存、包体、冷启动等（如适用）

### 2) 上下文与工具：MCP 连接与权限边界

- 先决定要不要接 MCP：能让“事实来源”更可靠就接；否则宁可不接。
- 默认优先只读能力：读 issue、读 repo、读监控；谨慎开启写入（建 PR、改配置、写数据库）。
- 明确允许操作的系统与范围：例如只允许读取某个项目空间，只允许在指定仓库创建分支。

### 3) 方案对比（最少两种）

让 AI 输出 2-3 种方案，并要求包含：

- 变更面：改哪些模块、影响哪些依赖方
- 风险：回滚难度、数据一致性、兼容风险、外部系统风险
- 验证：单测/集成测/灰度/观测

### 4) 实现（小步提交、可回滚）

推荐节奏：

1. 增量加测试或加可观测性（让行为可验证）
2. 只改一条主路径（保持 diff 小）
3. 覆盖错误分支与边界（避免“看起来能跑”）
4. 必要时加开关（feature flag / 配置开关）

### 5) 验证（本地 + CI）

至少包括：

- 构建/运行成功
- 单元测试或最小集成测试
- 关键路径手工验证（如果测试难覆盖）

### 6) 评审与合并

把 AI 产出当作“外包代码”对待：

- 不接受“解释不清楚但看起来没问题”
- 必须能说明改动原因、影响范围、验证方式、回滚策略

---

## MCP：把“上下文”变成“可调用工具”

MCP（Model Context Protocol）解决的不是“更会写代码”，而是“让 AI 拿到更可信的事实，并在受控范围内动手”。

### MCP 的工程化心智模型

- 你不是在给 AI 贴材料，而是在给它接“数据源”和“执行器”。
- 每接一个 server，就相当于给 agent 多了一条“手”和“眼睛”：必须做权限最小化、可追溯、可回滚。

### 什么时候该用 MCP

- 上下文来自外部系统且易变：issue tracker、设计系统、监控、数据库。
- 需要跨系统对齐事实：例如“这个 issue 的验收标准 + 这个 PR 的改动 + 线上错误率”。
- 需要可重复的查询：例如每次都要拉最近 24h 的错误 TopN。

### MCP 使用约束（强烈建议写进团队规范）

1. **先只读，后写入**：先允许读取与分析，验证价值，再逐步开放写入能力。
2. **写入必须确认点**：创建 PR、改配置、触发发布、写数据库这类操作，必须有明确的人类确认点。
3. **密钥与数据最小化**：最小权限 token；只提供必要字段；日志与数据先去敏。
4. **限制作用域**：server 只允许访问特定项目、特定目录、特定表、特定命名空间。
5. **把 MCP 输出当证据**：关键结论要求附来源（issue/日志/查询结果），避免凭空推断。

### MCP 常见坑与应对

- **结果不稳定**：分页/限流/时间窗口导致波动。
  - 应对：固定查询时间窗口；在 PR 里记录证据；必要时把关键输出落地为可复现文本。
- **隐式写入**：某些“看起来是查询”的能力可能触发写操作（例如创建草稿）。
  - 应对：默认禁用写入；或强制 dry-run；写入前二次确认。
- **权限过大**：token 绑定了全组织权限。
  - 应对：单项目 token + 只读为主 + 定期轮换 + 定期审计。

---

## Skills：把“好习惯”固化成“可复用指令包”

Skills 的价值在于：把成功的流程与约束从个人经验变成可复用的文本资产，让交付稳定、可复制、可审查。

### Skill 的设计原则

- **范围小**：一个 skill 解决一个问题域（例如“安全审计”、“迁移脚本”、“回归测试补齐”）。
- **输出明确**：固定交付物形态（patch/PR 描述/测试清单/风险清单）。
- **强约束**：明确禁止事项（不加依赖/不改 API/不写入外部系统）。
- **可验证**：要求列出验证命令与预期结果。
- **可演化**：版本化更新，避免一次性写成“百科全书”。

### 一个可落地的 Skill 模板（建议）

```
Skill 名称：$your-skill-name
适用场景：一句话
不适用场景：一句话

输入要求：
- 需求/bug 描述格式
- 必要上下文（文件/命令/日志）

硬性约束：
- 改动范围
- 依赖策略
- 风险控制（写入外部系统需确认）

交付物：
- patch 或逐文件修改说明
- 验证命令清单
- 风险与回滚策略（必填）

工作步骤：
1) 澄清问题（最多 N 个）
2) 计划与切分
3) 实施（小步）
4) 自检（对照清单）
```

### Skill 的维护建议（避免“技能债”）

- Skill 也要 code review：尤其是约束、权限、写入行为。
- 为 Skill 写“反例”：明确哪些场景不要用它，防止误用。
- 把团队最常见的失败模式写进 Skill（例如“不要改公共 API”“先补测试再重构”）。

---

## 蜂群模式：并行化的多 Agent 协作

蜂群模式适合“有并行空间”的任务：多模块、长链路、需要多类专长或大量验证。

### 蜂群的最小组织结构（建议）

- **Manager（统筹）**：维护单一真相（需求/DoD/风险/计划），分配任务包，收敛决策。
- **Implementer（实现）**：按任务包改代码、写测试、跑验证。
- **Reviewer（审计）**：独立 review（回归/安全/性能/可观测性），不参与实现，避免“自证正确”。
- 可选：**Tooling（工具）** 负责 MCP 连接、脚本化验证、生成报告。

### 蜂群协作协议（关键）

1. **统一输入**：Manager 维护一份任务简报（需求、DoD、范围、约束、验证、回滚）。
2. **任务包必须可集成**：每个任务包定义接口契约与完成条件。
3. **避免并发改同一处**：按文件/模块切分所有权，减少 merge 冲突与语义冲突。
4. **统一验收口径**：所有 Agent 以 DoD 与验证命令为准，不凭“感觉可行”。
5. **集成节奏固定**：每个任务包合并前必须过 Reviewer，自测日志要可复现。

### 蜂群的典型打法（可直接套）

- **实现 + 逆向审计**：实现 Agent 写代码；审计 Agent 按“最坏情况”找漏洞与回归。
- **拆模块并行**：每个 Agent 负责一个模块的改动与测试补齐；Manager 做集成与最终验证。
- **先证据后修复**：一个 Agent 专注复现与定位根因；根因确认后另一个 Agent 再写修复。

---

## 提示词模板（MCP/Skills/蜂群专项）

把方括号替换成你的内容即可。

### MCP 连接与边界（给 Manager）

```
请先把外部上下文通过 MCP 资源对齐（只读优先），然后输出：
1) 需求摘要（引用证据来源）
2) 验收标准（可执行）
3) 风险清单（含外部系统写入风险）
4) 计划切分（每步验证命令）
允许的 MCP 资源：[例如 @jira @github @sentry]
禁止事项：[例如禁止创建 PR/禁止写数据库/禁止修改配置]
```

### Skill 驱动实施（给 Implementer）

```
请按 $[skill-name] 的约束完成实现。
项目运行方式：[build/test/dev 命令]
改动范围：[目录/文件]
验收标准：[清单]
输出要求：给出可直接应用的 patch + 验证命令 + 回滚方案。
```

### 蜂群任务包模板（Manager 发给 Worker）

```
任务包名称：[例如 “补齐回归测试：登录流程”]
范围与所有权：[你负责哪些文件/模块]
接口契约：[输入/输出/事件/错误码/DB schema 等]
完成条件：
- 通过的测试/命令：
- 必须新增的测试：
- 必须更新的文档：
禁止事项：[不改公共 API/不加依赖/不改迁移脚本 等]
交付物：patch + 变更说明 + 风险与回滚。
```

### 蜂群审计模板（给 Reviewer）

```
你是独立审计者，不参与实现。请严格审查本次改动：
1) 回归风险（边界、错误处理、兼容）
2) 安全风险（鉴权、注入、SSRF、权限、数据泄露）
3) 外部工具调用风险（MCP 写入、token 权限、意外副作用）
4) 性能与资源（超时、重试、连接池、内存）
输出：按 阻塞/高/中/低 分级，每条给出“证据 + 修复建议 + 如何验证”。
```

---

## 质量门禁与自检清单（更适配 Agent）

提交/合并前，至少过一遍：

- 构建：`build` / `compile` 通过
- 测试：相关单测通过；新增行为有测试覆盖
- 静态检查：lint/format（如项目有）
- 错误处理：失败时返回值/异常/日志合理，不吞错
- 边界条件：空/极端输入、超时、重试、幂等
- 兼容性：不会破坏旧数据、旧 API、旧配置
- 性能：关键路径没有意外的复杂度爆炸；IO 不被放大
- 观测：关键失败路径可定位（日志/指标/trace，视项目而定）
- 回滚：能快速关闭（开关/回滚 PR/回滚配置）
- MCP：外部资源引用与调用符合约束；没有把敏感数据带入上下文；写入操作有明确确认点
- 蜂群：任务包交付物齐全；集成后跑过统一验证；没有“各自为政”的隐形假设

---

## 代码评审要点（人审 AI 产出，含工具风险）

建议按顺序检查：

1. **需求对齐**：改动是否满足验收标准，有没有偏题
2. **接口与边界**：输入校验、错误返回、超时、空值、并发
3. **副作用**：数据库/缓存/队列/文件系统写入是否可控、可回滚
4. **隐藏成本**：新增依赖、复杂度上升、后续维护负担
5. **测试有效性**：测试是否验证“行为”而不是实现细节
6. **工具风险**：是否引入新的外部依赖点（MCP server/脚本/配置），权限是否过大
7. **可追溯性**：关键决策是否有证据来源（issue/日志/查询结果），PR 描述是否可复现

把评审结论写进 PR 描述：

- 变更原因
- 影响范围
- 验证方式（命令 + 关键日志/截图）
- 回滚策略

---

## 安全与合规（含 MCP/权限/数据）

- 不把密钥、token、客户数据、生产日志原样交给 AI（先去敏/脱敏）
- 对外暴露接口：默认考虑鉴权、限流、注入、SSRF、路径遍历
- 文件系统/网络请求：默认考虑超时、重试、资源释放、重入幂等
- 数据迁移：默认做幂等与可回滚
- MCP：token 最小权限；server 只连可信来源；默认只读；写入需要人类确认；定期审计已连接的 server
- 蜂群：不要把敏感上下文广播给所有 Agent；按职责最小披露；审计 Agent 只拿必要证据

---

## 协作约定（团队落地）

建议团队形成统一约定，减少“每个人各玩各的”：

- 统一 DoD 模板（需求、验收、回滚、验证）
- 统一 PR 描述模板（原因、影响、验证、风险）
- 统一允许 AI 改动范围策略（例如核心模块必须人写/人审）
- 统一质量门禁（CI 必跑项、覆盖底线、lint/format）
- 统一日志与可观测规范（至少错误路径可定位）
- 统一 MCP 连接规范（允许的 server、默认权限、写入确认点、token 管理）
- 统一 Skills 的版本化与评审流程（skill 本身也需要 review）
- 统一蜂群协作协议（任务包模板、所有权切分、集成节奏）

---

## 常见失败模式与修复手段（新增：MCP/蜂群）

1. **AI 猜框架/猜版本**
   - 修复：明确语言、框架、版本、运行命令；贴真实入口文件名与目录结构
2. **AI 写了“能跑但不对”的代码**
   - 修复：先写验收用例/测试；让 AI 对照用例逐条满足
3. **改动面过大导致难评审**
   - 修复：强制切分为可独立合并的小 PR；每个 PR 有独立验证
4. **测试形同虚设（只测实现细节）**
   - 修复：以输入输出为中心写测试；覆盖错误分支与边界
5. **忽略回滚与兼容**
   - 修复：加开关/灰度；保持向后兼容；把回滚写进 PR 描述
6. **MCP 上下文“看起来权威但其实错窗/过期”**
   - 修复：固定查询时间窗口；在 PR 里记录证据；必要时把关键数据落地成可复现文本
7. **MCP 误写入外部系统**
   - 修复：默认只读；写入操作设置确认点；必要时 dry-run；审计 token 权限与作用域
8. **蜂群各自推进导致语义冲突**
   - 修复：Manager 维护单一真相；任务包定义接口契约；按模块所有权切分；先集成后扩大

---

## 本仓库相关参考

- Claude Code CLI 使用指南（含 MCP 集成章节）：`cli/cli.md`
- Qoder Quest 功能分析报告（工具/会话机制参考）：`ide/qoder/quest_analysis_report.md`

